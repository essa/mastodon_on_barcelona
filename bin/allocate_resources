#!/usr/bin/env ruby

require 'thor'
require 'json'
require 'aws-sdk'
require 'jbuilder'
require './lib/mastodon_on_barcelona/cf_executor'

include MastodonOnBarcelon

module HelperMethods
  def check_bcn
    json = `bcn api get /user`
    JSON.parse json
  rescue
    STDERR.puts $!
    STDERR.puts "bcn doesn't work, install it and login to your barcelona"
  end

  def check_aws_creadential
    cf_client.describe_stacks
  rescue
    STDERR.puts $!
    STDERR.puts "can't access to AWS, set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY properly"
  end

  def create_stack(stack)
    executor = CFExecutor.new(stack, cf_client)
    executor.create_or_update
    wait_cf_stack(executor)
  end

  private

  def network_attributes
    return @network_attributes if @network_attributes
    r = vpc_client.describe_vpcs(
      filters: [
        {
          name: "tag:barcelona",
          values: [district_name]
        },
      ]
    )
    raise "vpc for #{distrct_name} not found" unless r.first.vpcs.first
    vpc_id = r.first.vpcs.first.vpc_id

    r = vpc_client.describe_subnets(
      filters: [
        {
          name: "tag:barcelona",
          values: [district_name]
        },
        {
          name: "tag:Network",
          values: ["Private"]
        }

      ]
    )
    subnet_ids = r.first.subnets.map(&:subnet_id)
    subnet_cidrs = r.first.subnets.map(&:cidr_block)
    @network_attributes = {
      vpc_id: vpc_id,
      subnet_ids: subnet_ids,
      subnet_cidrs: subnet_cidrs
    }
  end

  def vpc_client
    @vpc_client ||= Aws::EC2::Client.new(
      region: region
    )
  end

  def cf_client
    @cf_client ||= Aws::CloudFormation::Client.new(
      region: region
    )
  end

  def wait_cf_stack(executor)
    while true
      sleep 10
      case executor.stack_status
      when "CREATE_COMPLETE"
        puts
        break
      when "UPDATE_COMPLETE"
        puts
        break
      when /_IN_PROGRESS/
        print "."
      else
        raise "Unexpected CF stack status #{executor.stack_status}"
      end
    end
    p executor.outputs
  end

end

class MastodonResourcesStack
  attr_reader :name, :network_attributes, :options
  def initialize(name, network_attributes, options)
    @name = name
    @network_attributes = network_attributes
    @options = options
  end

  def resource_name
    "mstdn-#{@name}"
  end

  def stack_name
    resource_name
  end

  def build
    Jbuilder.new do |j|
      j.Description description
      j.AWSTemplateFormatVersion "2010-09-09"

      j.Parameters do |jj|
        build_parameters(jj)
      end

      j.Resources do |jj|
        jj.DBSecurityGroup do |jjj| 
          db_security_group(jjj)
        end
        jj.RedisSubnetGroup do |jjj| 
          redis_subnet_group(jjj)
        end
        jj.RedisCluster do |jjj| 
          redis_cluster(jjj)
        end
        jj.DBSubnetGroup do |jjj| 
          db_subnet_group(jjj)
        end
        jj.DBInstance do |jjj| 
          db_instance(jjj)
        end
        jj.MediaBucket do |jjj| 
          media_bucket(jjj)
        end
      end

      j.Outputs do |json|
        build_outputs(json)
      end
    end
  end

  def build_parameters(json)
  end

  def build_outputs(j)
    j.MediaBucket do |jj| 
      jj.Description "S3 bucket name for storing media"
      jj.Value ref("MediaBucket")
    end
    j.DBEndPoint do |jj| 
      jj.Description "The end point of DB instance"
      jj.Value get_attr("DBInstance", "Endpoint.Address")
    end
    j.RedisEndPoint do |jj| 
      jj.Description "The end point of DB instance"
      jj.Value get_attr("RedisCluster", "RedisEndpoint.Address")
    end
  end

  def target!
    build.target!
  end

  private

  def db_security_group(j)
    subnet_cidrs = network_attributes[:subnet_cidrs]
    ingress = subnet_cidrs.map do |cidr|
       [
         {
           "IpProtocol" => "tcp",
           "FromPort" => 5432,
           "ToPort" => 5432,
           "CidrIp" => cidr
         },
         {
           "IpProtocol" => "tcp",
           "FromPort" => 6379,
           "ToPort" => 6379,
           "CidrIp" => cidr
         },
       ]
    end.flatten
    j.Type "AWS::EC2::SecurityGroup"
    j.Properties do
      j.GroupDescription "DB security group for mastodon #{resource_name}"
      j.VpcId network_attributes[:vpc_id]
      j.SecurityGroupIngress ingress
    end
  end

  def redis_subnet_group(j)
    j.Type "AWS::ElastiCache::SubnetGroup"
    j.Properties do
      j.CacheSubnetGroupName resource_name
      j.SubnetIds network_attributes[:subnet_ids]
      j.Description "redis subnet group for mastodon #{resource_name}"
    end
  end

  def redis_cluster(j)
    j.Type "AWS::ElastiCache::CacheCluster"
    j.Properties do
      j.ClusterName resource_name
      j.CacheNodeType "cache.t2.micro"
      j.Engine "redis"
      j.NumCacheNodes "1"
      j.VpcSecurityGroupIds [ ref("DBSecurityGroup")]
      j.CacheSubnetGroupName ref("RedisSubnetGroup")
    end
  end

  def db_subnet_group(j)
    j.Type "AWS::RDS::DBSubnetGroup"
    j.Properties do
      j.DBSubnetGroupDescription "db subnet group for mastodon #{resource_name}"
      j.SubnetIds network_attributes[:subnet_ids]
    end
  end

  def db_instance(j)
    j.Type "AWS::RDS::DBInstance"
    j.Properties do
      j.AllocatedStorage options[:allocated_strage]
      j.AllowMajorVersionUpgrade true
      j.AutoMinorVersionUpgrade true
      j.Engine "postgres"
      j.DBInstanceClass options[:db_instance_class]
      j.DBInstanceIdentifier resource_name
      j.DBName 'mstdn'
      j.MasterUsername options[:db_user]
      j.MasterUserPassword options[:db_password]
      j.MultiAZ options[:db_multi_az]
      j.VPCSecurityGroups [
        ref("DBSecurityGroup")
      ]
      j.DBSubnetGroupName ref("DBSubnetGroup")
      j.StorageType "gp2"
    end
  end

  def media_bucket(j)
    j.Type "AWS::S3::Bucket"
  end

  def description
    "AWS CloudFormation for Barcelona #{resource_name}"
  end

  def ref(r)
    {"Ref" => r}
  end

  def get_attr(*path)
    {"Fn::GetAtt" => path}
  end

end

class CLI < Thor
  include HelperMethods

  desc 'check_env', 'check environt for this command'
  def check_env
    puts "checking environment..."
    check_bcn
    check_aws_creadential
    puts "OK"
  end

  option :region
  option :name, required: true
  option :district_name, required: true
  option :allocated_strage, default: '5' # GB
  option :db_instance_class, default: 'db.t2.micro'
  option :db_multi_az, default: 'false'
  option :db_user, default: 'mastodon_admin'
  option :db_password, required: true
  desc 'execute_all', 'allocate all resources'
  def execute_all
    puts "start"
    #check_env
    stack = MastodonResourcesStack.new(options[:name], network_attributes, options)
    json = JSON.parse(stack.target!)
    puts JSON.pretty_generate json
    create_stack(stack)
    puts "end of allocate_resources"
  end

  default_task :execute_all

  private
  def region
    options[:region]
  end

  def district_name
    options[:district_name]
  end
end

CLI.start(ARGV)
